<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>MSA on Dongle</title>
        <link>https://kimsehyoung.github.io/tags/msa/</link>
        <description>Recent content in MSA on Dongle</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko</language>
        <lastBuildDate>Wed, 23 Aug 2023 19:44:57 +0900</lastBuildDate><atom:link href="https://kimsehyoung.github.io/tags/msa/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>gRPC Load Balancing</title>
        <link>https://kimsehyoung.github.io/post/grpc/grpc_load_balancing/</link>
        <pubDate>Wed, 23 Aug 2023 19:44:57 +0900</pubDate>
        
        <guid>https://kimsehyoung.github.io/post/grpc/grpc_load_balancing/</guid>
        <description>&lt;img src="https://kimsehyoung.github.io/post/grpc/grpc_load_balancing/load-balancing.png" alt="Featured image of post gRPC Load Balancing" /&gt;&lt;p&gt;Comming Soon&lt;/p&gt;
</description>
        </item>
        <item>
        <title>gRPC에 대해 알아보자</title>
        <link>https://kimsehyoung.github.io/post/grpc/grpc/</link>
        <pubDate>Wed, 23 Aug 2023 19:11:30 +0900</pubDate>
        
        <guid>https://kimsehyoung.github.io/post/grpc/grpc/</guid>
        <description>&lt;img src="https://kimsehyoung.github.io/post/grpc/grpc/grpc.png" alt="Featured image of post gRPC에 대해 알아보자" /&gt;&lt;h2 id=&#34;rpc&#34;&gt;RPC&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RPC&lt;/code&gt;(Remote Procedure Call)는 클라이언트가 서버의 procedure(함수)를 마치 로컬에 있는 것처럼 호출하는 것이다.
다음 동작 단계를 보면서, 어떤 건지 알아보자.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;RPC&lt;/code&gt;는 로컬 메서드를 호출하는 것처럼 보이지만, 클라이언트와 서버는 별도의 프로세스로 다른 주소 공간을 가지므로, 서로 통신을 위해서 JSON, Ptotobuf, Thrift 같은 &lt;code&gt;IDL&lt;/code&gt;(Interface Definition Language)로 호출 규약을 정의한다.&lt;/li&gt;
&lt;li&gt;rpcgen으로 &lt;code&gt;IDL&lt;/code&gt; 파일을 컴파일하여 클라이언트와 서버의 &lt;code&gt;Stub&lt;/code&gt; 코드를 생성한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stub&lt;/code&gt;은 Source code(C++, Java, Python, Go&amp;hellip;)의 형태로 서버에서는 Stub을 사용하여 프로시저에 대한 &lt;code&gt;기능 구현&lt;/code&gt;이 필요하다.&lt;/li&gt;
&lt;li&gt;각 클라이언트, 서버에서는 &lt;code&gt;Stub&lt;/code&gt; 코드를 같이 빌드한다.&lt;/li&gt;
&lt;li&gt;클라이언트는 전달할 매개변수를 &lt;code&gt;Mashalling&lt;/code&gt;하고, 로컬 Stub 프로시저를 호출하여 서버에 메시지를 전송한다.&lt;/li&gt;
&lt;li&gt;서버는 Stub을 통해 해당 프로시저가 호출되고, 매개변수를 &lt;code&gt;Unmarshalling&lt;/code&gt;하여 요청을 수행한 결과를 Mashalling하여 클라이언트에게 전송한다.&lt;/li&gt;
&lt;li&gt;클라이언트는 해당 서버 프로시저에 대한 결과를 받으며, 마치 &lt;code&gt;로컬 메서드&lt;/code&gt;를 호출하는 것처럼 사용을 할 수 있게 된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://kimsehyoung.github.io/post/grpc/grpc/how-rpc-works.png&#34;
	width=&#34;263&#34;
	height=&#34;221&#34;
	srcset=&#34;https://kimsehyoung.github.io/post/grpc/grpc/how-rpc-works_hu1646f65cbd4ca5e461afe8f60f3ef0b0_1418_480x0_resize_box_3.png 480w, https://kimsehyoung.github.io/post/grpc/grpc/how-rpc-works_hu1646f65cbd4ca5e461afe8f60f3ef0b0_1418_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;how-rpc-works&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;119&#34;
		data-flex-basis=&#34;285px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;(&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/en-us/windows/win32/rpc/how-rpc-works&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/en-us/windows/win32/rpc/how-rpc-works&lt;/a&gt;)&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;grpc&#34;&gt;gRPC&lt;/h2&gt;
&lt;p&gt;Google 내부에서 마이크로 서비스를 연결하는데 사용한 Stubby라는 RPC 인프라를 표준화한 오픈소스 프레임워크&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;가장 큰 특징은 &lt;code&gt;Probocol Buffers&lt;/code&gt;, &lt;code&gt;HTTP/2&lt;/code&gt;를 사용&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Protobuf&lt;/code&gt;는 google에서 만든 구조화된 데이터를 직렬화하는 방식으로 JSON 형식보다 작은 크기로 효율적&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HTTP/2&lt;/code&gt;는 헤더 압축, 이진 형식, 서버 푸시, 멀티플렉싱&amp;hellip; 으로 성능 향상을 가져옴&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Protobuf로 서비스 API를 정의
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HelloResponse&lt;/span&gt; {&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;service&lt;/span&gt; HelloService {&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#66d9ef&#34;&gt;returns&lt;/span&gt; (HelloResponse);&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;grpc-gateway&#34;&gt;gRPC-Gateway&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;gRPC&lt;/code&gt;는 좋은 장점들이 있지만, 몇 가지 고려할 점이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개발자들이 gRPC에 익숙지 않거나, 기존 서비스들이 REST 기반이라면 한 번에 서비스 전체에 gRPC를 적용하기 어려움&lt;/li&gt;
&lt;li&gt;브라우저에서 gRPC가 지원이 안 되기에, 추가적으로 &lt;code&gt;gRPC-Web&lt;/code&gt; 또는 &lt;code&gt;gRPC-Gateway&lt;/code&gt; 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 이유들로 &lt;code&gt;gRPC-Gateway&lt;/code&gt;를 사용할 수 있다.&lt;br&gt;
gRPC Gateway는 &lt;code&gt;REST&lt;/code&gt;를 &lt;code&gt;gRPC&lt;/code&gt;로 변환하는 &lt;code&gt;리버스 프록시 서버&lt;/code&gt;를 생성하는 방식으로 gRPC, REST 모두 호출 가능하게 해준다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kimsehyoung.github.io/post/grpc/grpc/grpc-gateway.png&#34;
	width=&#34;693&#34;
	height=&#34;475&#34;
	srcset=&#34;https://kimsehyoung.github.io/post/grpc/grpc/grpc-gateway_hudaed239fae906faca4e9c879395c2cc6_31372_480x0_resize_box_3.png 480w, https://kimsehyoung.github.io/post/grpc/grpc/grpc-gateway_hudaed239fae906faca4e9c879395c2cc6_31372_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;gRPC-Gateway&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;145&#34;
		data-flex-basis=&#34;350px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;(&lt;a class=&#34;link&#34; href=&#34;https://github.com/grpc-ecosystem/grpc-gateway&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/grpc-ecosystem/grpc-gateway&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id=&#34;pros-and-cons&#34;&gt;Pros and Cons&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Pros&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Polyglot 환경 (protobuf를 기반으로 gRPC가 지원하는 다양한 언어로 Stub코드 생성)&lt;/li&gt;
&lt;li&gt;양방향 통신 (Unary, Client streaming, server streaming, Bidirectional Streaming)&lt;/li&gt;
&lt;li&gt;네트워크 성능 (Protobuf, HTTP/2)&lt;/li&gt;
&lt;li&gt;API 문서 없이 Protobuf만으로 인터페이스 명세 (필요 시, gRPC-Gateway plugin으로 OpenAPI 문서 생성 가능)&lt;/li&gt;
&lt;li&gt;Interceptor, Load balancing 같은 유용한 내장 기능 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Cons&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSON/REST를 주로 사용했다면, 러닝 커브로 인한 도입 어려움&lt;/li&gt;
&lt;li&gt;gRPC는 브라우저 직접적인 지원이 안 되기에, 추가적인 방법이 필요&lt;/li&gt;
&lt;li&gt;TCP 연결을 유지하는 HTTP/2의 특성으로 인해, 로드 밸런싱의 어려움&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
